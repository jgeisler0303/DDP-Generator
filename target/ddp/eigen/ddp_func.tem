<<gentran(literal("\/\* File generated form template ddp_func.tem on ", eval(timedate()), ". Do not edit! \*\/", cr, cr))>>
#include "ddp.h"
#include <algorithm>

#ifndef PARALLEL_DERIVATIVES
    #define PARALLEL_DERIVATIVES 0
#endif

using namespace Eigen;
using namespace std;

#define mcond(cond, a, dummy, b) ((cond)? a: b)
#define mqapply(f, i, j) f(i, j)
#define sec(x) (1.0/cos(x))
#define csc(x) (1.0/sin(x))

<<tri_matrix_mode: true;>>

int n_params= <<gentran(eval(length(params)))$>>;
    
<<
block([i], for i:1 thru length(params) do gentran(literal("tParamDesc p_name", eval(i), "= {\"", eval(params[i][1]), "\", ", eval(if params[i][2]='k then -1 else params[i][2]), ", 0}\; // -> ", eval(if params[i][2]=1 then do_replacements(params[i][1]) else do_replacements(arraymake(params[i][1], [0]))),cr)))$
>>
int n_vars= 0;
    
tParamDesc *paramdesc[]= {<<block([i], for i:1 thru length(params) do (gentran(literal(&, "p_name", eval(i))), if i#length(params) then gentran(literal(", "))))$>>};

<<block([i], for i: 1 thru n_hfe do gentran(literal("#define mu_fe_", eval(i), " m->mu_fe[", eval(i-1), "]", cr)))$>>

<<block([i], for i: 1 thru n_hfi do gentran(literal("#define mu_fi_", eval(i), " m->mu_fi[", eval(i-1), "]", cr)))$>>

<<block([i], for i: 1 thru n_hle do gentran(literal("#define mu_le_", eval(i), " m->mu_le[", eval(i-1), "]", cr)))$>>

<<block([i], for i: 1 thru n_hli do gentran(literal("#define mu_li_", eval(i), " m->mu_li[", eval(i-1), "]", cr)))$>>

static int calcXVariableAux(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o);
static int calcXUVariableAux(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o);
static int calcFVariableAux(trajFin_t *t, const multipliersFin_t *m, const tOptSet *o);
static int calcLAuxDeriv(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o);
static int calcFAuxDeriv(trajFin_t *t, const multipliersFin_t *m, const tOptSet *o);
static int bp_derivsL(trajEl_t *t, int k, double **p);
static int bp_derivsF(trajFin_t *t, int k, double **p);

static int ddpL(trajEl_t *t, int k, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
    double __attribute__((unused)) **p= o->p;
    
<<print_aux_decl_assign([used_by_running], [], 4)>>
    
<<do_assign('t\-\>c, L, 4, 0)>>
    
    return 1;
}

static int ddpF(trajFin_t *t, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    const int __attribute__((unused)) k= o->n_hor;
    double __attribute__((unused)) **p= o->p;
    
<<print_aux_decl_assign([used_by_final], [], 4)>>

<<do_assign('t\-\>c, F, 4, 0)>>
    
    return 1;
}

static int ddpf(Ref<VectorX> x_next, const trajEl_t *t, int k, double **p, int N) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
<<print_aux_decl_assign([used_by_running], [], 4)>>
    
<<block([i], for i:1 thru nx do do_assign(x_next(i-1), f[x[i]], 4, 0))>>
    return 1;
}

void clampU(Ref<VectorU> u_, const trajEl_t *t, int k, double **p, int N) {
    double __attribute__((unused)) limit;
    const double __attribute__((unused)) *x= t->x.data();
    double __attribute__((unused)) *u= u_.data();
    
<<print_aux_decl_assign([used_by_running], [], 4)>>

<<block([i], for i: 1 thru nh do do_clamp(i))>>
}

static void limitsU(trajEl_t *t, int k, double **p, int N) {
    VectorU_int lower_idx= VectorU_int::Constant(-1);
    VectorU_int upper_idx= VectorU_int::Constant(-1);
    int *idx_;
    double *hx_, *h_sign;

    const double __attribute__((unused)) *x= t->x.data();
    double __attribute__((unused)) limit;
    
<<print_aux_decl_assign([used_by_running], [], 4)>>
<<print_deriv_decl_assign([used_by_running], [], 4)>>

    t->lower= VectorU::Constant(-INF);
    t->upper= VectorU::Constant(INF);
    
<<block([i], for i: 1 thru nh do do_limits('t\-\>, i))>>

    t->lower-= t->u;
    t->upper-= t->u; 

    for(int j= 0; j<2; j++) {
        if(j==0) {
            idx_= lower_idx.data();
            hx_= t->lower_hx.data();
            h_sign= t->lower_sign.data();
        } else {
            idx_= upper_idx.data();
            hx_= t->upper_hx.data();
            h_sign= t->upper_sign.data();
        }
        for(int i= 0; i<N_U; i++, h_sign++, hx_+= N_X) {
            switch(idx_[i]) {
                case -1:
                    h_sign[0]= 0.0;
                    break;
<<block([i], for i: 1 thru nh do (
  gentran(literal("                case ", eval(i-1), "\:", cr)),
  do_hx('hx_, 'h_sign, i, 4*5),
  gentran(literal("                    break\;", cr))
))>>
            }
        }
    }
}

int forward_pass(traj_t* c, const tOptSet* o, double alpha, double& csum, int cost_only) {
    int N= o->n_hor;
    double __attribute__((unused)) **params= o->p;
    
    const trajEl_t *t= o->nominal->t;
    trajEl_t *ct= c->t;
    trajFin_t *cf= &c->f;
    
    const multipliersEl_t *m= o->multipliers.t;
    const multipliersFin_t *mf= &o->multipliers.f;
    
    csum= 0.0;

    if(!cost_only)
        ct->x= o->x0;

    int k;
    for(k= 0; k<N; k++, t++, ct++, m++) {
        if(!cost_only) {
            if(alpha!=0.0) {
                VectorX dx= ct->x - t->x;
                ct->u.noalias()= t->u + t->l*alpha + t->L*dx;
            } else {
                ct->u= t->u;
            }
        }        
        if(!calcXVariableAux(ct, m, k, o)) break;
        
        if(!cost_only) {
            Ref<VectorU> ref(ct->u);
            clampU(ref, ct, k, params, N);
        }

        if(!calcXUVariableAux(ct, m, k, o)) break;
        
        if(!cost_only) {
            if(k>=N-1) {
                Ref<VectorX> ref(cf->x);
                if(!ddpf(ref, ct, k, params, N)) break;
            } else {
                Ref<VectorX> ref((ct+1)->x);
                if(!ddpf(ref, ct, k, params, N)) break;
            }
        }
        
        if(!ddpL(ct, k, o)) break;
        csum+= ct->c;        
    }
    
    if(k<N) {
        if(o->log_line) o->log_line->forward_pass_fail= k+1;
        return 0;
    }
    
    if(!calcFVariableAux(cf, mf, o) || !ddpF(cf, o)) {
        if(o->log_line) o->log_line->forward_pass_fail= N+1;
        return 0;
    }
    csum+= cf->c;
        
    if(o->log_line) o->log_line->forward_pass_fail= 0;
    return 1;
}

int calc_derivs(const tOptSet *o) {
    trajFin_t *f= &o->nominal->f;
    const multipliersFin_t *mf= &o->multipliers.f;

    if(!calcFAuxDeriv(f, mf, o) ||!bp_derivsF(f, o->n_hor, o->p)) {
        if(o->log_line) o->log_line->derivs_fail= o->n_hor+1;
    
        return 0;
    }
    
    int fail_k= -1;
    bool abort= false;
    #pragma omp parallel default(none) firstprivate(o, abort) shared(fail_k) if(PARALLEL_DERIVATIVES) num_threads(NUMBER_OF_THREADS)
    {
        #pragma omp for schedule(static)
        for(int k= o->n_hor-1; k>=0; k--) {
            if(!abort) {
                trajEl_t *t= o->nominal->t + k;
                multipliersEl_t *m= o->multipliers.t + k;
                
                if(!calcLAuxDeriv(t, m, k, o) || !bp_derivsL(t, k, o->p)) {
                    abort= true;
                    fail_k= k;
                }
                
                limitsU(t, k, o->p, o->n_hor);
            }
        }
    }
    
    if(fail_k>=0) {
        if(o->log_line) o->log_line->derivs_fail= fail_k+1;
        return 0;
    } else {
        if(o->log_line) o->log_line->derivs_fail= 0;
        return 1;
    }
}

static int calcXVariableAux(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    double __attribute__((unused)) **p= o->p;
    const double __attribute__((unused)) w_pen= o->w_pen_l;

<<print_aux([time_var, used_by_running], [denpends_on_u]);>>

<<print_aux_assign([time_var, used_by_running], [denpends_on_u], 4);>>

    return 1;
} 

static int calcXUVariableAux(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
    double __attribute__((unused)) **p= o->p;
    const double __attribute__((unused)) w_pen= o->w_pen_l;
    
<<print_aux_decl_assign([time_var, used_by_running], [denpends_on_u], 4);>>

<<print_aux([denpends_on_u, used_by_running], []);>>

<<print_aux_assign([denpends_on_u, used_by_running], [], 4);>>

    return 1;
} 

static int calcFVariableAux(trajFin_t *t, const multipliersFin_t *m, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    double __attribute__((unused)) **p= o->p;
    const double __attribute__((unused)) w_pen= o->w_pen_f;
    const int __attribute__((unused)) k= o->n_hor;
    
<<print_aux([time_var, used_by_final], []);>>

<<print_aux_assign([time_var, used_by_final], [], 4);>>

    return 1;
} 

static int calcLAuxDeriv(trajEl_t *t, const multipliersEl_t *m, int k, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
    const double __attribute__((unused)) w_pen= o->w_pen_l;
    double __attribute__((unused)) **p= o->p;
    
<<print_aux_decl_assign([used_by_running], [], 4);>>
<<print_deriv_decl_assign([used_by_running], [time_var], 4);>>

<<print_deriv([time_var, used_by_running], []);>>

<<print_deriv_assign([time_var, used_by_running], [], 4);>>

    return 1;
}

static int bp_derivsL(trajEl_t *t, int k, double **p) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
    
<<print_aux_decl_assign([used_by_running], [], 4);>>
<<print_deriv_decl_assign([used_by_running], [], 4);>>
    
// derivatives of f
<<print_jaco('t\-\>fx, fx, true);>>

<<print_jaco('t\-\>fu, fu, true);>>

#if FULL_DDP
<<if not(all_zero(fxx)) then print_jaco2('t\-\>fxx, fxx, true);>>

<<if not(all_zero(fuu)) then print_jaco2('t\-\>fuu, fuu, true);>>

<<if not(all_zero(fxu)) then print_jaco2('t\-\>fxu, fxu, true);>>
#endif

// derivatives of L
<<print_grad('t\-\>cx, Lx, true);>>

<<print_hess('t\-\>cxx, Lxx, true);>>

<<print_grad('t\-\>cu, Lu, true);>>

<<print_hess('t\-\>cuu, Luu, true);>>

<<print_hess('t\-\>cxu, Lxu, true);>>

    return 1;
}

static int calcFAuxDeriv(trajFin_t *t, const multipliersFin_t *m, const tOptSet *o) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) w_pen= o->w_pen_f;
    double __attribute__((unused)) **p= o->p;
    const int __attribute__((unused)) k= o->n_hor;
    
<<print_aux_decl_assign([used_by_final], [], 4);>>
<<print_deriv_decl_assign([used_by_final], [time_var], 4);>>

<<print_deriv([time_var, used_by_final], []);>>

<<print_deriv_assign([time_var, used_by_final], [], 4);>>

    return 1;
}

static int bp_derivsF(trajFin_t *t, int k, double **p) {
    const double __attribute__((unused)) *x= t->x.data();
<<print_aux_decl_assign([used_by_final], [], 4);>>
<<print_deriv_decl_assign([used_by_final], [], 4);>>

    
<<print_grad('t\-\>cx, Fx, true);>>

<<print_hess('t\-\>cxx, Fxx, true);>>
    return 1;
}

static int init_running(trajEl_t *t, const tOptSet *o) {
    double __attribute__((unused)) **p= o->p;
    
    
    for(int k= 0; k<o->n_hor; k++, t++) {
<<print_aux([used_by_running], [time_var]);>>
<<print_aux_assign([used_by_running], [time_var], 4);>>

<<print_deriv([used_by_running], [time_var]);>>
<<print_deriv_assign([used_by_running], [time_var], 4);>>


// derivatives of L
<<print_grad('t\-\>cx, Lx, false);>>

<<print_hess('t\-\>cxx, Lxx, false);>>

<<print_grad('t\-\>cu, Lu, false);>>

<<print_hess('t\-\>cuu, Luu, false);>>

<<print_hess('t\-\>cxu, Lxu, false);>>

// derivatives of f
<<print_jaco('t\-\>fx, fx, false);>>

<<print_jaco('t\-\>fu, fu, false);>>

#if FULL_DDP
<<if not(all_zero(fxx)) then print_jaco2('t\-\>fxx, fxx, false) else gentran(literal("    memset(t\-\>fxx, 0, sizeof(double)*N_X*sizeofQxx)\;", cr));>>

<<if not(all_zero(fuu)) then print_jaco2('t\-\>fuu, fuu, false) else gentran(literal("    memset(t\-\>fuu, 0, sizeof(double)*N_X*sizeofQuu)\;", cr));>>

<<if not(all_zero(fxu)) then print_jaco2('t\-\>fxu, fxu, false) else gentran(literal("    memset(t\-\>fxu, 0, sizeof(double)*N_X*sizeofQxu)\;", cr));>>
#endif
    }
    
    return 1;
}

static int init_final(trajFin_t *t, const tOptSet *o) {
    double __attribute__((unused)) **p= o->p;
    const int __attribute__((unused)) k= o->n_hor;

<<print_aux([used_by_final], [time_var]);>>
<<print_aux_assign([used_by_final], [time_var], 4);>>

<<print_deriv([used_by_final], [time_var]);>>
<<print_deriv_assign([used_by_final], [time_var], 4);>>

<<print_grad('t\-\>cx, Fx, false);>>

<<print_hess('t\-\>cxx, Fxx, false);>>

    return 1;
}

int init_trajectory(traj_t *t, const tOptSet *o) {
    if(!init_running(t->t, o)) return 0;
    if(!init_final(&t->f, o)) return 0;
    
    return 1;
}

static int init_multipliers_running(const tOptSet *o) {
    multipliersEl_t __attribute__((unused)) *m= o->multipliers.t;

    for(int k= 0; k<o->n_hor; k++, m++) {
<<if  n_hle#0 then gentran(literal("        for(int i= 0\; i<", eval(n_hle), "\; i++) { m->mu_le[i]= 0.0\; }", cr))>>

<<if  n_hli#0 then gentran(literal("        for(int i= 0\; i<", eval(n_hli), "\; i++) { m->mu_li[i]= 1.0\; }", cr))>>
    }
    
    return 1;
}

static int init_multipliers_final(tOptSet *o) {
    multipliersFin_t __attribute__((unused)) *m= &o->multipliers.f;

<<if  n_hfe#0 then gentran(literal("    for(int i= 0\; i<", eval(n_hfe), "\; i++) { m->mu_fe[i]= 0.0\; }", cr))>>

<<if  n_hfi#0 then gentran(literal("    for(int i= 0\; i<", eval(n_hfi), "\; i++) { m->mu_fi[i]= 1.0\; }", cr))>>
    
    return 1;
}

int init_multipliers(tOptSet *o) {
    if(!init_multipliers_running(o)) return 0;
    if(!init_multipliers_final(o)) return 0;
    
    return 1;
}

int init_opt(tOptSet *o) {
    for(int i= 0; i<NUMBER_OF_THREADS+1; i++)
        if(!init_trajectory(&o->trajectories[i], o)) return 0;

    o->nominal= &o->trajectories[0];
    for(int i= 1; i<NUMBER_OF_THREADS+1; i++)
        o->candidates[i-1]= &o->trajectories[i];
    
    if(!init_multipliers(o)) return 0;
    
    return 1;
}

void calc_constraint_violation(tOptSet *o) {
    o->maxConstraint= 0.0;
    {
    trajEl_t *t= o->nominal->t;
    multipliersEl_t __attribute__((unused)) *m= o->multipliers.t;
    const double __attribute__((unused)) inv_w_pen= 1.0/o->w_pen_l;
    double __attribute__((unused)) infeasability_noncomplementarity;
    
    for(int k= 0; k<o->n_hor; k++, m++, t++) {
<<print_aux_decl_assign([used_by_running], [], 8);>>

<<block([i], for i: 1 thru n_hle do (
    gentran(literal("        o->maxConstraint= std::max(o->maxConstraint, std::abs(", eval(do_replacements(concat('hle_, i))), "))\;", cr))
))>>

        // according to ON AUGMENTED LAGRANGIAN METHODS WITH GENERAL LOWER-LEVEL CONSTRAINTS, https://doi.org/10.1137/060654797
<<block([i], for i: 1 thru n_hli do (
    gentran(literal("        infeasability_noncomplementarity= std::max(", eval(do_replacements(concat('hli_, i))), ", -1.0*", eval(concat('mu_li_, i)), "*inv_w_pen)\;", cr)),
    gentran(literal("        o->maxConstraint= std::max(o->maxConstraint, std::abs (infeasability_noncomplementarity))\;", cr))
))>>
    }
    }
    {
    trajFin_t __attribute__((unused)) *t= &o->nominal->f;
    multipliersFin_t __attribute__((unused)) *m= &o->multipliers.f;
    const double __attribute__((unused)) inv_w_pen= 1.0/o->w_pen_f;
    double __attribute__((unused)) infeasability_noncomplementarity;

<<print_aux_decl_assign([used_by_final], [], 4);>>
    
<<block([i], for i: 1 thru n_hfe do (
    gentran(literal("    o->maxConstraint= std::max(o->maxConstraint, std::abs(", eval(do_replacements(concat('hfe_, i))), "))\;", cr))
))>>

        // according to ON AUGMENTED LAGRANGIAN METHODS WITH GENERAL LOWER-LEVEL CONSTRAINTS, https://doi.org/10.1137/060654797
<<block([i], for i: 1 thru n_hfi do (
    gentran(literal("    infeasability_noncomplementarity= std::max(", eval(do_replacements(concat('hfi_, i))), ", -1.0*", eval(concat('mu_fi_, i)), "*inv_w_pen)\;", cr)),
    gentran(literal("    o->maxConstraint= std::max(o->maxConstraint, std::abs (infeasability_noncomplementarity))\;", cr))
))>>
    }
}

static int update_multipliers_running(tOptSet *o) {
    trajEl_t *t= o->nominal->t;
    multipliersEl_t __attribute__((unused)) *m= o->multipliers.t;
    const double __attribute__((unused)) w_pen= o->w_pen_l;
    double __attribute__((unused)) **p= o->p;

    for(int k= 0; k<o->n_hor; k++, m++, t++) {
        const double __attribute__((unused)) *x= t->x.data();
        const double __attribute__((unused)) *u= t->u.data();
        
<<print_aux_decl_assign([used_by_running], [], 8);>>
        
<<block([i], for i: 1 thru n_hle do do_assign(concat(mu_le_, i), mu_le_next[i], 8, 0))>>

// inequality constraints according to D. Ruxton: Differential dynamic programming applied to continuous optimal control problems with state variable inequality constraints, also suggested by Bertsekas, D. P. (1982). Constrained optimization and Lagrange multiplier methods. pp 308, hat P_I version of P_I, Example 2 
<<block([i], for i: 1 thru n_hli do (
  gentran(literal("        if(", eval(do_replacements(concat('hli_, i))), ">=0) {", cr)),
  do_assign(concat('mu_li_, i), mu_li_A_next[i], 4*3, 0),
  gentran(literal("        } else {", cr)),
  do_assign(concat('mu_li_, i), mu_li_I_next[i], 4*3, 0),
  gentran(literal("        }", cr, cr))
))>>
    }
        
    return 1;
}

static int update_multipliers_final(tOptSet *o) {
    trajFin_t *t= &o->nominal->f;
    multipliersFin_t __attribute__((unused)) *m= &o->multipliers.f;
    
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) w_pen= o->w_pen_f;
    double __attribute__((unused)) **p= o->p;
    
<<print_aux_decl_assign([used_by_final], [], 4);>>
    
    int __attribute__((unused)) k= o->n_hor;

<<block([i], for i: 1 thru n_hfe do do_assign(concat(mu_fe_, i), mu_fe_next[i], 4, 0))>>

<<block([i], for i: 1 thru n_hfi do (
  gentran(literal("    if(", eval(do_replacements(concat('hfi_, i))), ">=0) {", cr)),
  do_assign(concat('mu_fi_, i), mu_fi_A_next[i], 4*2, 0),
  gentran(literal("    } else {", cr)),
  do_assign(concat('mu_fi_, i), mu_fi_I_next[i], 4*2, 0),
  gentran(literal("    }", cr, cr))
))>>

    return 1;
}

int update_multipliers(tOptSet *o) {
    if(!update_multipliers_running(o)) return 0;
    if(!update_multipliers_final(o)) return 0;

    return 1;
}

int get_g_size() {
<<if member(g, arrays) then gentran(literal("return(", eval(length(flatten(rest(arrayinfo(g), 2)))), ")\;", cr)) else gentran(return(0))>>
}

int calcG(double g[], const trajEl_t *t, int k, double **p) {
    const double __attribute__((unused)) *x= t->x.data();
    const double __attribute__((unused)) *u= t->u.data();
    
<<print_aux_decl_assign([used_by_running], [], 4);>>
    
<<block([i, i_: 0], if member(g, arrays) then for i in flatten(rest(arrayinfo(g), 2)) do (do_assign('g[i_], g[i], 4, 0), i_:i_+1))>>
    return(1);
} 
