if member(h, arrays) then
block([i_work],
  h_: map(lambda([i_work], arrayapply(h, [i_work])), flatten(rest(arrayinfo(h), 2))),
  
  nh: length(h_),
  hu: make_array(flonum, nh, nu),
  hu_: flatten(args(jacobian(h_, u))),
  fillarray(hu, hu_),

  hx: make_array(flonum, nh, nx),
  hx_: flatten(args(jacobian(h_, x))),
  fillarray(hx, hx_),

  for i_work: 1 thru nh do (
    hu_: makelist(hu[i_work-1, i_], i_, 0, nu-1),
    if depends_on_u(h_[i_work]) then
      error("constaint (", h_[i_work], ") may only depend directly on one input"),

    if apply("+", map(lambda([x], if equal(x, 0) then 0 else 1), hu_))#1 then
      error("constaint (", h_[i_work], ") may depend on only one input. hu: ", hu_),
     
    if not(equal(abs(apply("+", hu_)), 1)) then
      error("coefficient of input in constaint (", h_[i_work], ") must be 1 or -1")
  )
)
else nh: 0$
