load(graphs)$

get_index(dg_s, dg_dg):= block([dg_i],
    dg_i: sublist_indices(dg_dg@syms, lambda([x], x=dg_s)),
    if length(dg_i)>1 then
        error("something went wrong. the symbol list contains the symbol ", dg_s, " more than once"),
    if length(dg_i)<1 then
        -1
    else
        dg_i[1]
)$

add_symbol(dg_s, dg_dg):= block([dg_i],
    dg_i: get_index(dg_s, dg_dg),
    if dg_i<0 then (
        dg_i: length(dg_dg@syms)+1,
        dg_dg@syms: append(dg_dg@syms, [dg_s]),
        if member(dg_s, values) then
            dg_dg@aux_vars: endcons(dg_s, dg_dg@aux_vars)
        else if not member(dg_s, arrays) and not member(dg_s, x)  and not member(dg_s, u) then
            dg_dg@all_params: endcons(dg_s, dg_dg@all_params),
            
        add_vertex(dg_i, dg_dg@g),
        set_vertex_label (dg_i, dg_s, dg_dg@g)
    ),
    
    dg_i
)$

build_dep_graph(dg_s, [varargs]):= block([dg_i, dg_j, dg_sym, dg_syms, dg_dist],
    if length(varargs)<1 then (
        defstruct(depgraph(g, syms, aux_vars, all_params)),
        dg_dg: new(depgraph),
        dg_dg@g: create_graph ([], [], true),
        dg_dg@syms: [],
        dg_dg@aux_vars: [],
        dg_dg@all_params: []
    ) else
        dg_dg: varargs[1],
    
    if length(varargs)<2 then
        dg_i: add_symbol(dg_s, dg_dg)
    else
        dg_i: varargs[2],
    
    if equal(length(out_neighbors(dg_i, dg_dg@g)), 0) then (
        if member(dg_s, arrays) then
            dg_syms: listofvars(listarray(dg_s))
        else
            if member(dg_s, values) then
                dg_syms: listofvars(ev(dg_s))
            else
                dg_syms: [],
        
        dg_syms: setify(dg_syms),
        for dg_sym in dg_syms do (
            dg_j: add_symbol(dg_sym, dg_dg),
            add_edge([dg_i, dg_j], dg_dg@g),
            dg_dist: vertex_distance (dg_j, dg_i, dg_dg@g),
            if dg_dist<inf then
                error("Circular definition of dependencies involving ", get_vertex_label(dg_i, dg_dg@g), " and ", get_vertex_label(dg_j, dg_dg@g), ". Distance is ", dg_dist),
            build_dep_graph(dg_sym, dg_dg, dg_j)
        )
    ),
    
    dg_dg
)$

get_dependencies(dg_x):= block([dg_l, dg_v, dg_dg_l_sorted],
  dg_l: sublist(dependencies, lambda([x_], is(op(x_)=dg_x))),
  if length(dg_l)=0 then return([]),
  dg_l: args(dg_l[1]),
  dg_l_sorted: [],
  for dg_v in x do (
    if member(dg_v, dg_l) then (
        dg_l: delete(dg_v, dg_l),
        dg_l_sorted: endcons(dg_v, dg_l_sorted)
    )
  ),
  for dg_v in u do (
    if member(dg_v, dg_l) then (
        dg_l: delete(dg_v, dg_l),
        dg_l_sorted: endcons(dg_v, dg_l_sorted)
    )
  ),
  append(dg_l_sorted, dg_l)
)$

add_dependency(dg_x, dg_d):= block(
  depends(dg_x, cons(dg_d, get_dependencies(dg_x)))
)$

set_depends(dg_s, dg_dg, [varargs]):= block([dg_i, dg_j, dg_sym],
    if listp(dg_s) then (
        for dg_sym in listofvars(dg_s) do
            set_depends(dg_sym, dg_dg),
            
        return
    ),
    
    if length(varargs)<1 then
        dg_dep: dg_s
    else
        dg_dep: varargs[1],

    dg_i: get_index(dg_s, dg_dg),
    if dg_i>0 then (
        for dg_j in in_neighbors(dg_i, dg_dg@g) do (
            add_dependency(dg_dg@syms[dg_j], dg_dep),
            set_depends(dg_dg@syms[dg_j], dg_dg, dg_dep)
        )
    )
)$

set_flag(dg_s, dg_flag):= put(if subvarp(dg_s) then op(dg_s) else dg_s, true, dg_flag);

set_symbol_flag(dg_s, dg_flag, dg_dg):= block([dg_i, dg_j],
    dg_i: get_index(dg_s, dg_dg),
    if dg_i>0 then
        set_flag(dg_dg@syms[dg_i], dg_flag)
);

set_children_flag(dg_s, dg_flag, dg_dg):= block([dg_i, dg_j],
    dg_i: get_index(dg_s, dg_dg),
    if dg_i>0 then (
        for dg_j in out_neighbors(dg_i, dg_dg@g) do (
            set_flag(dg_dg@syms[dg_j], dg_flag),
            set_children_flag(dg_dg@syms[dg_j], dg_flag, dg_dg)
        )
    )
)$

set_parents_flag(dg_s, dg_flag, dg_dg):= block([dg_i, dg_j],
    dg_i: get_index(dg_s, dg_dg),
    if dg_i>0 then (
        for dg_j in in_neighbors(dg_i, dg_dg@g) do (
            set_flag(dg_dg@syms[dg_j], dg_flag),
            set_parents_flag(dg_dg@syms[dg_j], dg_flag, dg_dg)
        )
    )
)$

transfer_properties(dg_a, dg_b):= block([dg_pro, dg_i],
  dg_pro: flatten(sublist(apply(properties, [dg_a]), lambda([x], is(x[1]="user properties")))),
  for dg_i: 2 thru length(dg_pro) do (
    put(dg_b, get(dg_a, dg_pro[dg_i]), dg_pro[dg_i])
  )
)$

dg_tree: build_dep_graph(f);
dg_tree: build_dep_graph('L, dg_tree);
dg_tree@aux_vars: delete('L, dg_tree@aux_vars);
dg_tree: build_dep_graph('F, dg_tree);
dg_tree@aux_vars: delete('F, dg_tree@aux_vars);
if member(h, arrays) then dg_tree: build_dep_graph(h, dg_tree);

set_children_flag('F, used_by_final, dg_tree);
set_children_flag('L, used_by_running, dg_tree);
set_children_flag(f, used_by_running, dg_tree);
if member(h, arrays) then set_children_flag(h, used_by_running, dg_tree);

for dg_u in u do set_parents_flag(dg_u, denpends_on_u, dg_tree);
for dg_tv in dg_time_var_symbols do (set_symbol_flag(dg_tv, time_var, dg_tree), set_parents_flag(dg_tv, time_var, dg_tree));
set_depends([x, u], dg_tree);

is_time_var(dg_a):= block([dg_s, dg_tv],
    if subvarp(dg_a) then dg_a: op(dg_a),
    
    if stringp(dg_a) or numberp(dg_a) then
        false
    elseif atom(dg_a) then (
        get(dg_a, time_var)
    ) else (
        /*if length(listofvars(dg_a))=1 then error("no expression: ", dg_a),*/
        dg_tv: false,
        for dg_s in listofvars(dg_a) do
            if is_time_var(dg_s) then (
                /*print(string(dg_s)),*/
                dg_tv: true,
                return(dg_tv)
            ),
        dg_tv
    )
);
