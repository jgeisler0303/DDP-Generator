allvars: append(listofvars(listarray(f)),listofvars(F), listofvars(L));
if member(h, arrays) then allvars: append(allvars, listofvars(listarray(h)));

allvars: setdifference(setify(allvars), {k});
allparams: setdifference(setdifference(allvars, setify(x)), setify(u));
arrayparams: subset(allparams, subvarp);

scalarparams: setdifference(allparams, arrayparams);

aux_vars: subset(scalarparams, lambda([x], member(x, values)))$

get_dependencies(x):= block([l_work],
  l_work: sublist(dependencies, lambda([x_], is(op(x_)=x))),
  if length(l_work)=0 then return([]),
  args(l_work[1])
/* make sure states come last */
)$

get_xu_dep(a_work):= block([xu_dep: {}, dep, d_work],
  deps: get_dependencies(a_work),
  /*print("dependencies of ", a_work, ": ", deps),*/
  for d_work in deps do
    if member(d_work, append(x, u)) then
      xu_dep: append(xu_dep, {d_work})
    else
      xu_dep: append(xu_dep, get_xu_dep(d_work)),
  
  xu_dep
)$

add_dependency(x, d_work):= block(
  depends(x, cons(d_work, get_dependencies(x)))
)$

rem_dep(x, d_work):= block(
  depends(x, delete(d_work, get_dependencies(x)))
)$

recurse_deps(d_work, parents):= block([new_dep, new_deps, new_p, new_aux: parents, res, r_local, xu],
  new_p: setify(listofvars(ev(d_work))),
  new_deps: subset(new_p, lambda([x], member(x, values))),
  for new_dep in new_deps do (
    if member(new_dep, parents) then
      error("circular definition of dependencies: ", new_dep, " depends on itself directly or via one of ", parents)
    else
      if not(member(new_dep, new_aux)) then (
        if length(parents)#0 then   (d_work, new_dep),

        res: recurse_deps(new_dep, append(parents, [new_dep])),
        new_aux: append(new_aux, [new_dep]),
        for r_local in res do
          new_aux: append(delete(r_local, new_aux), [r_local])
      )
  ),
  new_params: append(new_params, setdifference(new_p, new_deps)),
  for xu in append(x, u) do
    if member(xu, new_params) then (
      new_params: delete(xu, new_params),
      if length(parents)#0 then add_dependency(d_work, xu)
    ),
  /*print("new aux in ", d_work, ": ", new_aux),*/
  new_aux
)$

new_params: {}$
top_level_aux: aux_vars$
aux_vars: reverse(recurse_deps('top_level_aux, []))$

set_aux_used_by(e_work, lable):= block([a_work],
  for a_work in listofvars(e_work) do
    if member(a_work, aux_vars) then (
      put(a_work, true, lable),
      set_aux_used_by(ev(a_work), lable)
    )
)$

set_aux_used_by(F, used_by_final);
set_aux_used_by(L, used_by_running);
set_aux_used_by(listarray(f), used_by_running);
if member(h, arrays) then set_aux_used_by(listarray(h), used_by_running);

transfer_properties(a_work, b_work):= block([pro, i],
  pro: flatten(sublist(apply(properties, [a_work]), lambda([x], is(x[1]="user properties")))),
  for i: 2 thru length(pro) do (
    put(b_work, get(a_work, pro[i]), pro[i])
  )
)$


/* make implicit state dependencies explicit and remove direct dependencies */
block([a_work],
  for a_work in aux_vars do
    depends(a_work, sort(listify(get_xu_dep(a_work))))
)$

aux_def: [];
aux_deriv: [];
depends_on_u_aux: u;
does_depend_on_u(e_work):= not(apply('freeof, endcons(e_work, depends_on_u_aux)));

/* aux and derivatives definitions */
block([i_work, a_work, d1_work, d2_work, d_work, rem_d, dname_work, ddname_work,eva],
  for i_work: 1 thru length(aux_vars) do (
    a_work: aux_vars[i_work],
    eva: ev(a_work),
    aux_def: endcons([a_work, eva], aux_def),
    apply(defrule, [concat('rule, '_, a_work), arraymake('aux_vars, [i_work]), concat(aux_prefix, a_work)]),
    if is_time_var(eva) then
      time_var_symbols: cons(a_work, time_var_symbols),
    if does_depend_on_u(eva) then
      depends_on_u_aux: cons(a_work, depends_on_u_aux),

    rem_d: get_dependencies(a_work),
    for d1_work in get_dependencies(a_work) do (
      d_work: diff(eva, d1_work),
      dname_work: concat('diff_, a_work, '_, d1_work),
      if not(numberp(d_work)) then (
        aux_deriv: endcons([dname_work, d_work], aux_deriv),
        apply(defrule, [concat('rule, '_, dname_work), dname_work, concat(daux_prefix, dname_work)]),
        if is_time_var(d_work) then
          time_var_symbols: cons(dname_work, time_var_symbols),
        apply(gradef, [a_work, d1_work, dname_work]),
        transfer_properties(a_work, dname_work),

        for d2_work in rem_d do (
          dd_work: diff(eva, d1_work, 1, d2_work, 1),
          if not(numberp(dd_work)) then (
            d_ab: sort([d1_work, d2_work]),
            ddname_work: concat('diff_2, a_work, '_, d_ab[1], '_, d_ab[2]),
            aux_deriv: endcons([ddname_work, dd_work], aux_deriv),
            apply(defrule, [concat('rule, '_, ddname_work), ddname_work, concat(daux_prefix, ddname_work)]),
            if is_time_var(dd_work) then
              time_var_symbols: cons(ddname_work, time_var_symbols),
            apply(gradef, [dname_work, d2_work, ddname_work]),
            transfer_properties(a_work, ddname_work)
          ) else
            apply(gradef, [dname_work, d2_work, dd_work])
        )
      ) else 
        apply(gradef, [a_work, d1_work, d_work]),
      
      rem_d: delete(d1_work, rem_d)
    )  
  )
)$


allparams: append(setdifference(allparams, setify(aux_vars)), new_params);
arrayparams: subset(allparams, subvarp);
scalarparams: setdifference(allparams, arrayparams);

scalarparams: setdifference(scalarparams, {w_pen});
scalarparams: setdifference(scalarparams, setify(mu_hfe_all));
scalarparams: setdifference(scalarparams, setify(mu_hfi_all));
scalarparams: setdifference(scalarparams, setify(mu_hle_all));
scalarparams: setdifference(scalarparams, setify(mu_hli_all));

if does_depend_on_u(F) then
  error("F may not depend on u");

scalar_list: block([p_work, l_work: makelist (), i_work: 0], for p_work in scalarparams do (l_work:endcons([p_work, 1, 0, i_work], l_work), i_work: i_work+1), l_work);

array_list: block([p_work, idxes, idx_work, maxidx, l_work: makelist(), aps: {}, i_work:length(scalar_list)],
  for p_work in arrayparams do
    aps:adjoin(op(p_work), aps),
  for p_work in aps do (
    idxes: map(args, subset(arrayparams, lambda([x], is(op(x)=p_work)))),
    maxidx: 0,
    for idx_work in idxes do (
      if length(idx_work)>1 then
        error("only one dimensional arrays supported found: ", idx_work)
      else
        if integerp(idx_work[1]) then
          if maxidx=k then
            error("found index k and other integer index mixed in param ", p_work)            
          else
            maxidx: max(maxidx, idx_work[1])
        else
          if idx_work[1]=k then
            if maxidx=0 then
              maxidx: k
            else
                error("found index k and other integer index mixed in param ", p_work)            
          else
            error("only integer indices or ksupported, found: ", idx_work, " in param ", p_work)
     ),
     if maxidx>0 then maxidx: maxidx+1,
     l_work:endcons([p_work, maxidx, 0, i_work], l_work),
     i_work: i_work+1
  ),
  l_work
);

params: append(scalar_list, array_list);
params: sort(params, lambda([a, b], orderlessp(a[1], b[1])));

block([i],
  for i: 1 thru length(params) do
    params[i][4]: i-1
);

